pPsi = function(q, p1, p2)
{
pf( p2/p1*(q-1), p1, p2, lower.tail=FALSE)
}
qPsi = function(p, p1, p2)
{
p1/p2 * qf(p, p1, p2, lower.tail=FALSE) + 1
}
Adj.Alpha = function(alpha, Xs)
{
p = dim(Xs)[2]
N = dim(Xs)[1]
## Using bisection method to calcualte the adjusted alpha
iter <- 0
b = 1
a = 0
DELTA = 1
while  ( DELTA > 0.001 ) {
mid <- (a + b) / 2
f.low = Obj.Func(a, Xs, p, N, alpha)
f.mid = Obj.Func(mid, Xs, p, N, alpha)
f.upper = Obj.Func(b, Xs, p, N, alpha)
if (f.mid == 0) {
break
} else if (f.mid * f.low < 0) {
b <- mid
} else {
a <- mid
}
DELTA = f.upper - f.low
}
mid
}
Obj.Func = function(alpha_temp,  Xs, p, n, alpha)
{
SUM = 0
for(i in 1:p)
{
Xs.minus.i = Xs[,-i]
tau.i = det( cor(Xs.minus.i) )
SUM = SUM + pPsi( tau.i * qPsi(alpha_temp, p, N-p), p, N-p )
}
SUM - alpha
}
BH.cut = function(pvalue, alpha)
{
p.sort = sort(pvalue, decreasing=FALSE )
R = max( ( p.sort < c(1:length(pvalue))/length(pvalue) * alpha )* c(1:length(pvalue) ) )
if( R>0 )
{
rej.ind = ( pvalue <=  p.sort[R])*1
}else{
rej.ind = array(0, p )
}
rej.ind
}
p = 100
N = 500
rho = 0.2
numSim = 100
Sigma = diag(1, p)
for(i in 1:(p-1))
for(j in (i+1):p )
{
Sigma[i,j] = rho^(abs(i-j))
Sigma[j,i] = rho^(abs(i-j))
}
pPsi = function(q, p1, p2)
{
pf( p2/p1*(q-1), p1, p2, lower.tail=FALSE)
}
qPsi = function(p, p1, p2)
{
p1/p2 * qf(p, p1, p2, lower.tail=FALSE) + 1
}
Adj.Alpha = function(alpha, Xs)
{
p = dim(Xs)[2]
N = dim(Xs)[1]
## Using bisection method to calcualte the adjusted alpha
iter <- 0
b = 1
a = 0
DELTA = 1
while  ( DELTA > 0.001 ) {
mid <- (a + b) / 2
f.low = Obj.Func(a, Xs, p, N, alpha)
f.mid = Obj.Func(mid, Xs, p, N, alpha)
f.upper = Obj.Func(b, Xs, p, N, alpha)
if (f.mid == 0) {
break
} else if (f.mid * f.low < 0) {
b <- mid
} else {
a <- mid
}
DELTA = f.upper - f.low
}
mid
}
Obj.Func = function(alpha_temp,  Xs, p, n, alpha)
{
SUM = 0
for(i in 1:p)
{
Xs.minus.i = Xs[,-i]
tau.i = det( cor(Xs.minus.i) )
SUM = SUM + pPsi( tau.i * qPsi(alpha_temp, p, N-p), p, N-p )
}
SUM - alpha
}
BH.cut = function(pvalue, alpha)
{
p.sort = sort(pvalue, decreasing=FALSE )
R = max( ( p.sort < c(1:length(pvalue))/length(pvalue) * alpha )* c(1:length(pvalue) ) )
if( R>0 )
{
rej.ind = ( pvalue <=  p.sort[R])*1
}else{
rej.ind = array(0, p )
}
rej.ind
}
p = 100
N = 500
rho = 0.2
numSim = 100
Sigma = diag(1, p)
for(i in 1:(p-1))
for(j in (i+1):p )
{
Sigma[i,j] = rho^(abs(i-j))
Sigma[j,i] = rho^(abs(i-j))
}
Xs = rmvnorm(N, mean=rep(0,p), sigma=Sigma)
install.packages("mvtnorm")
Xs = rmvnorm(N, mean=rep(0,p), sigma=Sigma)
library(mvtnorm)
Xs = rmvnorm(N, mean=rep(0,p), sigma=Sigma)
sample_mean = apply( Xs, 2, mean)
Mat_A = (N-1)*cov(Xs)
R_mat = cor(Xs)
## Calcualte the test statistic
T_sq = ( diag(Mat_A) + N * sample_mean^2 )/( diag(Mat_A) * det(R_mat) )
pvalue = pf( (N-p)/p*(T_sq-1), p, N-p, lower.tail=FALSE )
## Calculate the adjusted alpha level
adj.alpha=Adj.Alpha(alpha, Xs)
alpha=0.05
Xs = rmvnorm(N, mean=rep(0,p), sigma=Sigma)
sample_mean = apply( Xs, 2, mean)
Mat_A = (N-1)*cov(Xs)
R_mat = cor(Xs)
## Calcualte the test statistic
T_sq = ( diag(Mat_A) + N * sample_mean^2 )/( diag(Mat_A) * det(R_mat) )
pvalue = pf( (N-p)/p*(T_sq-1), p, N-p, lower.tail=FALSE )
## Calculate the adjusted alpha level
adj.alpha=Adj.Alpha(alpha, Xs)
library(mvtnorm)
pPsi = function(q, p1, p2)
{
pf( p2/p1*(q-1), p1, p2, lower.tail=FALSE)
}
qPsi = function(p, p1, p2)
{
p1/p2 * qf(p, p1, p2, lower.tail=FALSE) + 1
}
Adj.Alpha = function(alpha, Xs)
{
p = dim(Xs)[2]
N = dim(Xs)[1]
## Using bisection method to calcualte the adjusted alpha
iter <- 0
b = 1
a = 0
DELTA = 1
while  ( DELTA > 0.001 ) {
mid <- (a + b) / 2
f.low = Obj.Func(a, Xs, p, N, alpha)
f.mid = Obj.Func(mid, Xs, p, N, alpha)
f.upper = Obj.Func(b, Xs, p, N, alpha)
if (f.mid == 0) {
break
} else if (f.mid * f.low < 0) {
b <- mid
} else {
a <- mid
}
DELTA = f.upper - f.low
}
mid
}
Obj.Func = function(alpha_temp,  Xs, p, n, alpha)
{
SUM = 0
for(i in 1:p)
{
Xs.minus.i = Xs[,-i]
tau.i = det( cor(Xs.minus.i) )
SUM = SUM + pPsi( tau.i * qPsi(alpha_temp, p, N-p), p, N-p )
}
SUM - alpha
}
BH.cut = function(pvalue, alpha)
{
p.sort = sort(pvalue, decreasing=FALSE )
R = max( ( p.sort < c(1:length(pvalue))/length(pvalue) * alpha )* c(1:length(pvalue) ) )
if( R>0 )
{
rej.ind = ( pvalue <=  p.sort[R])*1
}else{
rej.ind = array(0, p )
}
rej.ind
}
p = 20
N = 500
alpha=0.05
rho = 0.2
numSim = 100
Sigma = diag(1, p)
for(i in 1:(p-1))
for(j in (i+1):p )
{
Sigma[i,j] = rho^(abs(i-j))
Sigma[j,i] = rho^(abs(i-j))
}
Xs = rmvnorm(N, mean=rep(0,p), sigma=Sigma)
sample_mean = apply( Xs, 2, mean)
Mat_A = (N-1)*cov(Xs)
R_mat = cor(Xs)
## Calcualte the test statistic
T_sq = ( diag(Mat_A) + N * sample_mean^2 )/( diag(Mat_A) * det(R_mat) )
pvalue = pf( (N-p)/p*(T_sq-1), p, N-p, lower.tail=FALSE )
pvalue
adj.alpha=Adj.Alpha(alpha, Xs)
adj.alpha
res = BH.cut(pvalue, adj.alpha)
res
T_sq
p = 100
N = 500
alpha=0.05
rho = 0.2
numSim = 100
Sigma = diag(1, p)
for(i in 1:(p-1))
for(j in (i+1):p )
{
Sigma[i,j] = rho^(abs(i-j))
Sigma[j,i] = rho^(abs(i-j))
}
Xs = rmvnorm(N, mean=rep(0,p), sigma=Sigma)
sample_mean = apply( Xs, 2, mean)
Mat_A = (N-1)*cov(Xs)
R_mat = cor(Xs)
## Calcualte the test statistic
T_sq = ( diag(Mat_A) + N * sample_mean^2 )/( diag(Mat_A) * det(R_mat) )
pvalue = pf( (N-p)/p*(T_sq-1), p, N-p, lower.tail=FALSE )
pvalue
T_sq
R_mat
det(R_mat)
( diag(Mat_A) * det(R_mat) )
diag(Mat_A)
( diag(Mat_A) + N * sample_mean^2 )
( diag(Mat_A) + N * sample_mean^2 )/( diag(Mat_A) * det(R_mat) )
sample_mean
N
diag9Mat_A
diag(Mat_A)
getwd()
setwd("~/Dropbox/programming/github/rMAB_version2023/R/")
read.csv("../result/norm/10000/Arm_5/uniform/experiments_lil_ucb_original_norm/experiments_regret.csv" )
ran.lil.ucb.unif = read.csv("../result/norm/10000/Arm_5/uniform/experiments_lil_ucb_linear_const_norm/experiments_regret.csv" )
ran.lil.ucb.unif
ran.lil.ucb.wf = read.csv("../result/norm/10000/Arm_5/water_filling/experiments_lil_ucb_linear_const_norm/experiments_regret.csv" )
## Summarize Table 1.
lil.ucb.orig = read.csv("../result/norm/10000/Arm_5/uniform/experiments_lil_ucb_original_norm/experiments_regret.csv" )
ran.lil.ucb.unif = read.csv("../result/norm/10000/Arm_5/uniform/experiments_lil_ucb_linear_const_norm/experiments_regret.csv" )
ran.lil.ucb.wf = read.csv("../result/norm/10000/Arm_5/water_filling/experiments_lil_ucb_linear_const_norm/experiments_regret.csv" )
lil.ucb.orig
ran.lil.ucb.unif
